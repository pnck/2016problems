可执行文件格式：64bit .wpf应用（【需要.net framework4.5】）  64bit dll
编译环境：VS2015 64bit
估计分值： 400（以简单异或比较crackme为10分计）

测试流程：
运行环境中必须安装64位 .net framework 4.5

运行exe后会弹出.net程序的安装向导，安装成功后运行，点击加载插件选择附带的dll，点击选择图片选择某图片，点击调用插件可以看到对图片加密后的效果
图片分辨率最好跟附带图片分辨率一致，因为算法在切分图片的时候会因对大小取整产生误差导致无法完美复原。附带图片的分辨率经过测试不会产生这种误差。

还原算法没写，所以无法提供测试，但源码里的两个变换都是可逆且没有丢弃信息的，肯定是能写出逆算法的



提示&原理摘要：

wpf应用只是个壳，逻辑在dll里，将bmp文件像素异或加密后切块重组
需要逆向出重组算法和异或加密算法然后倒过来把图片处理一遍
调试的时候需要现场重写一个简单的dll loader来调用其中导出函数
否则.net的托管代码和dll的native代码一起调试难度很大

逻辑都在dll里。Process函数接受待处理的文件名，然后打开文件并通过FileMapping将其映射到内存空间直接操作。

dll中实现了两种加密变换，一种是逐像素变换：

先将每像素亮度整体shift（将大对比度缩小（0,255本来亮度差255，shift之后只有1））
然后各颜色分量值相互异或，保留其中一个作为还原依据
之后再与固定变换表中的值进行异或

另一种对图片进行切分并交换位置
交换规则……
略


解题需要重新写出加密的逆算法。拖时间题。

hdu{MixtureTastesBad}