可执行文件格式：64bit 控制台exe
编译环境：VS2015 64bit
估计分值： 300（以简单异或比较crackme为10分计）

测试流程：
运行后输入正确flag会显示:)，否则显示:( 
只要输入内容前半部分与flag相同即可


提示&原理摘要：

运行时会对自身进行hotpatch
改动了SEH异常表（.pdata）某些结构以及执行流中的某几处代码使其执行流程不按正常逻辑进行

输入内容后，会循环调用一个假的加密函数，该函数设置了一个人为的内存访问违例使程序转向SEH处理，按照正常逻辑，该异常被捕获后转到紧接的__except块进行处理
然而hotpatch修改了异常处理的目标跳转地址，访问违例发生后会跳到真正的加密函数，加密函数执行末尾又会通过一个人为的访问违例跳回循环继续处。
在循环开始前，程序会将已patch的.text段复制到某处内存保存，并在每轮循环中检查当前代码段与保存的镜像是否一致，如不一致说明当前代码段可能被修改或下了软件断点，然后清空.text段内容。

由于程序有自修改代码，真正的执行流无法通过静态分析得出，必须进行动态跟踪，而跟踪过程中又会有大量的异常消息同时还有上述反调试机制，所以调试起来有一定难度

同时为减少内存搜索的特征特意将反馈消息给得极其简单，只有保存在栈上的两个符号，加大发现入手点的难度

要获得flag必须对 x64 windows seh机制有一定了解，起码了解异常处理的流程与调用的系列api，断点下在异常展开的api里然后跟踪到返回至程序处，再把反调试函数patch掉
然后才能正常进行动态调试

实际的程序逻辑仅仅是将输入字串查表变换后与固定数字异或并比对，搞清楚逻辑后写个脚本将数据逆推回去即可


hdu{YouMakeChoicesRight}